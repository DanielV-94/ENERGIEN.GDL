const canvas=document.getElementById("lightRaysCanvas"),heroSection=document.querySelector(".financing-hero");if(canvas&&heroSection){const e=new THREE.Scene,n=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3),o=new THREE.WebGLRenderer({canvas:canvas,alpha:!0,antialias:!0});o.setSize(window.innerWidth,heroSection.offsetHeight),o.setPixelRatio(Math.min(window.devicePixelRatio,2)),n.position.set(0,0,5),n.lookAt(0,0,0);const t=[],i=24;for(let n=0;n<i;n++){const o=new THREE.Shape;o.moveTo(0,0),o.lineTo(-.15,-30),o.lineTo(.15,-30),o.lineTo(0,0);const a={depth:.05,bevelEnabled:!1},r=new THREE.ExtrudeGeometry(o,a),s=new THREE.ShaderMaterial({transparent:!0,side:THREE.DoubleSide,depthWrite:!1,blending:THREE.AdditiveBlending,uniforms:{color1:{value:new THREE.Color(16768409)},color2:{value:new THREE.Color(16753920)},opacity:{value:.25},time:{value:0}},vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vPosition;\n        \n        void main() {\n          vUv = uv;\n          vPosition = position;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform vec3 color1;\n        uniform vec3 color2;\n        uniform float opacity;\n        uniform float time;\n        varying vec2 vUv;\n        varying vec3 vPosition;\n        \n        void main() {\n          // Distance from center (top of ray)\n          float distFromTop = length(vPosition.xy);\n          float fadeDistance = distFromTop / 30.0;\n          \n          // Fade out towards the bottom\n          float alpha = opacity * (1.0 - fadeDistance);\n          \n          // Add subtle pulsing\n          alpha *= 0.8 + sin(time + vPosition.y * 0.1) * 0.2;\n          \n          // Color gradient\n          vec3 color = mix(color1, color2, fadeDistance * 0.5);\n          \n          // Brighter at center\n          float centerGlow = 1.0 - smoothstep(0.0, 0.3, abs(vUv.x - 0.5));\n          color += color1 * centerGlow * 0.3;\n          \n          gl_FragColor = vec4(color, alpha);\n        }\n      "}),l=new THREE.Mesh(r,s),d=n/i*Math.PI*2;l.rotation.z=d,l.position.y=3,l.position.z=.5*Math.random()-2,l.userData={angle:d,offset:.1*n,rotationSpeed:.05+.03*Math.random()},e.add(l),t.push(l)}const a=100,r=new THREE.BufferGeometry,s=new Float32Array(3*a),l=new Float32Array(a),d=[];for(let e=0;e<a;e++){const n=Math.random()*Math.PI*2,o=8*Math.random();s[3*e]=Math.cos(n)*o,s[3*e+1]=8*Math.random()-2,s[3*e+2]=2*(Math.random()-.5)-2,l[e]=.15*Math.random()+.05,d.push({y:-(.01*Math.random()+.005)})}r.setAttribute("position",new THREE.BufferAttribute(s,3)),r.setAttribute("size",new THREE.BufferAttribute(l,1));const c=new THREE.ShaderMaterial({transparent:!0,depthWrite:!1,blending:THREE.AdditiveBlending,uniforms:{color:{value:new THREE.Color(16768409)}},vertexShader:"\n      attribute float size;\n      varying float vAlpha;\n      \n      void main() {\n        vAlpha = 1.0 - (position.y + 2.0) / 10.0;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_PointSize = size * (300.0 / -mvPosition.z);\n        gl_Position = projectionMatrix * mvPosition;\n      }\n    ",fragmentShader:"\n      uniform vec3 color;\n      varying float vAlpha;\n      \n      void main() {\n        float dist = length(gl_PointCoord - vec2(0.5));\n        if (dist > 0.5) discard;\n        float alpha = (1.0 - dist * 2.0) * vAlpha * 0.6;\n        gl_FragColor = vec4(color, alpha);\n      }\n    "}),v=new THREE.Points(r,c);e.add(v);let h=0;function animate(){requestAnimationFrame(animate),h+=.01,t.forEach((e=>{e.rotation.z+=.01*e.userData.rotationSpeed,e.material.uniforms.time.value=h+e.userData.offset}));const i=v.geometry.attributes.position.array;for(let e=0;e<a;e++)i[3*e+1]+=d[e].y,i[3*e+1]<-6&&(i[3*e+1]=3);v.geometry.attributes.position.needsUpdate=!0,o.render(e,n)}function onResize(){const e=window.innerWidth,t=heroSection.offsetHeight;n.aspect=e/t,n.updateProjectionMatrix(),o.setSize(e,t)}animate(),window.addEventListener("resize",onResize),onResize()}else;